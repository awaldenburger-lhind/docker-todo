# Cheat Sheet
This cheat sheet is meant to provide a high level overview of the project and help you to get started with the Docker examples provided.

## Motivation
This project aims to provide a simple playground for multi container Docker projects and to serve as a starting point to further examine Docker. 

## Prerequisites
This project uses Java (8), Maven and Docker along with Docker Compose. If you're not using Maven, don't worry, simply use one of the wrapper scripts (mvnw*) in order to build
the project. For all other dependencies you'll find links that will provide further information here:

* Java: http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html
* Docker: https://docs.docker.com/engine/installation/
* Docker Compose: https://docs.docker.com/compose/install/

__IMPORTANT__: If you're working on Linux, do not simply install Docker and Docker Compose straight from your distro's repositories, as the versions found there may be outdated. Make sure to check
the version first. All examples were created and tested using Version 1.13 of Docker and Docker Compose. So anything >= Version 1.13 should be ok.

## Project Structure
The below tree shows the basic project file structure and gives a few hints on what you will find where. Use this as your map. More details are explained further on in the document.

    .
    ├── backend                                                     // the backend service project root
    │   ├── Dockerfile                                              // this Dockerfile will build an image for the backend - note that you'll need to perform a Maven build first
    │   ├── mvnw                                                    // Maven wrapper script for Mac/Linux/Cygwin
    │   ├── mvnw.cmd                                                // Maven wrapper script for Windows
    │   ├── pom.xml                                                 // Maven pom.xml with the basic build settings
    │   └── src                                                     // Java sources
    │       ├── main
    │       │   ├── java
    │       │   │   └── de
    │       │   │       └── bendahl
    │       │   │           ├── SwaggerConfig.java                  // Swagger setup (for more information see: http://swagger.io/)
    │       │   │           ├── TodoApplication.java                // the main entry point of the app
    │       │   │           ├── TodoEndpoint.java                   // REST endpoint
    │       │   │           ├── Todo.java                           // the Todo entity class for DB and JSON mapping
    │       │   │           └── TodoRepository.java                 // Spring JPA repository that handles data access
    │       │   └── resources                                       // non-code resources used by the backend project
    │       │       ├── application.properties                      // app settings
    │       │       └── data.sql                                    // initial data to populate the in H2 DB
    │       └── test
    │           └── java
    │               └── de
    │                   └── bendahl
    │                       └── TodoApplicationTests.java           // standard unit test generated by Spring Boot
    ├── docker-compose.yml                                          // basic docker-compose file that will deploy frontend and backend, using the Docker Hub repositories
    ├── frontend                                                    // the frontend service project root
    │   ├── Dockerfile                                              // this Dockerfile will build an image for the frontend - note that you'll need to perform a Maven build first 
    │   ├── mvnw                                                    // Maven wrapper script for Mac/Linux/Cygwin
    │   ├── mvnw.cmd                                                // Maven wrapper script for Windows
    │   ├── pom.xml                                                 // Maven pom.xml with the basic build settings
    │   └── src                                                     // Java sources
    │       ├── main
    │       │   ├── java
    │       │   │   └── de
    │       │   │       └── bendahl
    │       │   │           ├── DemoFrontendApplication.java        // Main entry point of the frontend application
    │       │   │           ├── TodoChangeListener.java             // interface used to create a change event binding 
    │       │   │           ├── Todo.java                           // todo class that maps to and from JSON
    │       │   │           ├── TodoLayout.java                     // layout that is used to display the todo list items
    │       │   │           ├── TodoList.java                       // controls the behavior of the actual todo list
    │       │   │           ├── TodoService.java                    // the service that handles all backend calls
    │       │   │           └── TodoUI.java                         // setup of basic layout and components of the application
    │       │   └── resources
    │       │       ├── application.properties                      // app settings - the backend URL is setup here
    │       │       ├── static                                      // not needed in this case - generated by Spring Boot
    │       │       └── templates                                   // not needed in this case - generated by Spring Boot
    │       └── test
    │           └── java
    │               └── de
    │                   └── bendahl
    │                       └── DemoFrontendApplicationTests.java   // standard unit test generated by Spring Boot
    └── README.MD                                                   // Start here ;-)


### The Backend
The backend consists of a tiny REST service that is built on top of Spring Boot. 
Swagger is integrated in the service in order to make it easy to play around with a few simple requests and get a feel for what it actually does.
Besides Java and Spring Boot, H2 DB is used as a data store in order to keep things simple and not require an addtional database(container) to be set up.
The backend listens on port 8081 and the base URL is: http://HOSTNAME_GOES_HERE:8081/todos.
The swagger web ui is located at: http://HOSTNAME_GOES_HERE:8081/swagger-ui.html

Note that the H2 DB is set up to use file storage, in order to be able to use this project to not only demonstrate networking in Docker, but also some storage basics. As long as the backend container is not removed, the data will not be lost upon container restart/stop. The default storage location of the db is the file `/tmp/todo.mv.db` within the container (see application.properties for details). This should be a sensible default in most cases. If, however, you wish to override this behavior, it's as simple as setting the environment variable `DB_FILENAME` in order to change it. The format of the filename is `<path>/<filename>`, where filename will automatically be expanded to "filename.mv.db".

Building the Docker image:
* cd into the backend directory first 
* then enter the following (omitting the ":1.0" will create an image tagged as "latest")
    docker build -t todo-backend:1.0 .
 
__IMPORTANT__: The docker-compose.yml will not use your local image by default, as it references "bendahl/todo-backend:1.0". You can change this, of course, and reference yours instead.

Creating and running a container based on your local image:
docker run -d --name backend -p 8081:8081 todo-backend:1.0

This will essentially create and immediately start a new container named "backend" based on your local image created above. You can now connect to it on the exposed port 8081. 

Use <code> docker ps </code> to see all running containers  

<code>docker stop backend</code> will stop the container
 
Use <code>docker ps -a </code> to see all containers (including the ones that are not running)
 
<code>docker rm backend</code> will delete the container


### The Frontend
The frontend application is a simple Vaadin Todo app, largely taken from ttps://github.com/vaadin-marcus/spring-boot-todo/. It also uses Java, Spring Boot and Maven as 
its stack. In order to find the backend reliably and elegantly without requiring things like service discovery or hard wiring everything, it will rely on DNS and uses an 
environment variable in the application.properties to extract the hostname of the backend. This is very important, since the hostname defined by this environment variable 
needs to match the name given to the backend service within the docker-compose.yml file. The reason for this is simply that docker-compose will assign that name to the backend
container as its hostname and ensure that all containers on the default network will be able to resolve it via DNS. The frontend listens on port 8080. Go to 
http://HOSTNAME_GOES_HERE:8080 to see the web ui.

Building the Docker image:
* cd into the frontend directory first 
* then enter the following (omitting the ":1.0" will create an image tagged as "latest")
    docker build -t todo-frontend:1.0 .
 
__IMPORTANT__: The docker-compose.yml will not use your local image by default, as it references "bendahl/todo-frontend:1.0". You can change this, of course, and reference yours instead.

Creating and running a container based on your local image:
docker run -d --name frontend -p 8080:8080 --link backend todo-frontend:1.0

This will essentially create and immediately start a new container named "frontend" based on your local image created above and link the backend container to it. You can now connect to it on port 8080. 

Use <code> docker ps </code> to see all running containers.  

<code>docker stop backend</code> will stop the container
 
Use <code>docker ps -a </code> to see all containers (including the ones that are not running).
 
<code>docker rm backend</code> will delete the container


__IMPORTANT__: The frontend only works correctly if a backend service is available. Therefore, you should start the backend first. Also, note that container linking is 
officially deprecated and may be dropped in future versions (see: https://docs.docker.com/engine/userguide/networking/default_network/dockerlinks/). It is used here as an easy
means to quickly link up two containers. Instead, you may also use a custom network setup, as described in the Docker documentation as well. The best way
to accomplish this is probably through the use of Docker Compose, which is a) very easy to setup and b) offers some advanced features (see: https://docs.docker.com/compose/overview/#features).


### Docker Compose File
If you would like to try the Docker Compose example, you do not even need to build the two sub projects, as the script simply uses my personal Docker Hub account to pull
the needed images. The images are built based on the two sources here on Github. In order to keep things simple for people wanting to use this repository, it contains the whole app,
frontend and backend. The downside of this is that integrating with Docker Hub is not as nice, since it is usually a 1 to 1 mapping of a Github to Docker Hub repository. This is the
sole reason why there is no automated/trusted build (yet). On the other hand, you may always build your own images and modify the docker-compose.yml file to use these images
instead (maybe a nice first exercise...).

_A few points worth noting:_
* For convenience reasons, the docker-compose configuration exposes the frontend on port 80
* The example shows how to deal with dependencies amongst containers: The frontend defines a dependency on the backend
* An environment variable is used to set the backend's host name within the frontend container (used for discovery)
* The restart policy is set to "unless-stopped", which will always restart the containers, even on server reboot, 
except if the containers were stopped intentionally using <code>docker stop</code> or <code>docker-compose stop</code>

## Credits
Special thanks goes to Marcus Hellberg for his excellent Vaadin example that really did prove to be a great time saver when creating the frontend application. The original 
Vaadin project is located here on Github at: https://github.com/vaadin-marcus/spring-boot-todo/

## Miscellaneous
I hope that this little project will be useful for you in your quest to learn more about Docker and hopefully provide a fun playground to get started with multi container apps.
Let me know if you've got any further ideas/suggestions! Feel free to clone the heck out of this repo and reuse whatever part you want. Cheers!